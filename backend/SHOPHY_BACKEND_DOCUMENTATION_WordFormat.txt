SHOPIFY XENO BACKEND - COMPLETE DOCUMENTATION

TABLE OF CONTENTS
1. PROJECT OVERVIEW
2. TECHNOLOGY STACK
3. ARCHITECTURE
4. CORE COMPONENTS
5. DATABASE SCHEMA
6. API ENDPOINTS
7. AUTHENTICATION
8. DATA INGESTION
9. MIDDLEWARE
10. INTERVIEW QUESTIONS
11. DIRECTORY STRUCTURE

================================================================================

1. PROJECT OVERVIEW

Shopify Xeno Backend is a production-ready, secure, tenant-isolated API service for multi-tenant Shopify data ingestion and business insights. It enables Shopify store owners to connect their stores, automatically sync product, customer, and order data, and access actionable business insights through a dashboard.

TARGET USERS
- Shopify store owners who want a holistic view of their business performance across multiple stores
- Authorized personnel who need secure access to business insights

CORE PROBLEMS SOLVED
1. Aggregates data from multiple Shopify stores
2. Maintains up-to-date information with real-time sync
3. Generates actionable insights without manual data exports
4. Provides secure access to authorized team members

================================================================================

2. TECHNOLOGY STACK

BACKEND TECHNOLOGIES
- Node.js (v18+) - JavaScript runtime environment
- Express.js (v5) - Web application framework
- Prisma ORM - Database toolkit and ORM
- PostgreSQL - Primary database
- Redis (Upstash) - Caching layer
- Passport.js - Authentication middleware
- JWT - Token-based authentication

KEY DEPENDENCIES
- @prisma/client - Database client
- @upstash/redis - Redis client
- axios - HTTP client
- cors - Cross-Origin Resource Sharing
- date-fns - Date manipulation
- dotenv - Environment variable management
- express-rate-limit - Rate limiting
- express-session - Session management
- helmet - Security headers
- jsonwebtoken - JWT implementation
- morgan - HTTP request logging
- node-cron - Task scheduling
- passport-google-oauth20 - Google OAuth strategy

================================================================================

3. ARCHITECTURE

OVERALL ARCHITECTURE PATTERN
The system follows a layered architecture pattern with the following components:

1. API Layer (Express.js): Handles routes, controllers, and request/response handling
2. Authentication Service: Manages Google OAuth for admin dashboard access
3. Shopify Integration Service: Handles OAuth flow and API client for Shopify
4. Data Ingestion Service: Manages full and delta sync mechanisms
5. Data Persistence Layer (Prisma): Handles database operations with multi-tenant isolation
6. Caching Layer (Redis): Improves performance through response caching

ARCHITECTURAL PATTERNS USED
1. Middleware Pattern: Used extensively in Express.js for request processing
2. Repository Pattern: Implemented in the data access layer
3. Service Layer Pattern: Business logic is encapsulated in service classes
4. Adapter Pattern: Used for integrating with external systems like Shopify API
5. Strategy Pattern: Used for authentication with different providers

MULTI-TENANT ARCHITECTURE
- Each Shopify store is treated as a separate tenant
- Data isolation is maintained through tenant IDs in all database queries
- Tenant context is resolved through middleware using headers or query parameters
- Redis cache keys are tenant-specific to prevent data leakage

================================================================================

4. CORE COMPONENTS

1. CONFIGURATION FILES (/config)
- passport.js: Google OAuth configuration
- redis.js: Redis client setup and configuration
- shopify.js: Shopify API client and utilities including HMAC verification

2. CONTROLLERS (/controllers)
Handle HTTP requests and responses:
- auth.controller.js: Google OAuth flow handlers
- ingest.controller.js: Data ingestion endpoints
- insights.controller.js: Business insights endpoints
- shopify.controller.js: Shopify OAuth and callback handlers
- webhook.controller.js: Webhook processing

3. MIDDLEWARE (/middleware)
Express middleware for request processing:
- adminOnly.js: Restricts access to admin users
- auth.js: JWT token authentication
- cache.js: Response caching using Redis
- errorHandler.js: Centralized error handling
- rateLimiter.js: Rate limiting protection
- sessionAuth.js: Session-based authentication
- shopifyHmac.js: Shopify webhook verification
- tenant.js: Tenant resolution from headers/query parameters

4. MODELS (/models)
Database models and Prisma client initialization:
- db.js: Prisma client initialization

5. REPOSITORIES (/repositories)
Data access layer implementing the Repository pattern:
- customer.repo.js: Customer data operations
- order.repo.js: Order data operations
- product.repo.js: Product data operations
- tenant.repo.js: Tenant data operations
- webhookEvent.repo.js: Webhook event logging

6. ROUTES (/routes)
API route definitions:
- auth.routes.js: Authentication routes
- ingest.routes.js: Data ingestion routes
- insights.routes.js: Business insights routes
- shopify.routes.js: Shopify integration routes

7. SERVICES (/services)
Business logic implementation:
- ingest.service.js: Data ingestion logic (full and delta sync)
- shopify.service.js: Shopify integration logic
- webhook.service.js: Webhook processing logic

8. UTILITIES (/utils)
Utility functions:
- crypto.js: Cryptographic utilities
- env.js: Environment variable validation
- shopify-ingest.js: CLI utility for data ingestion

================================================================================

5. DATABASE SCHEMA

KEY MODELS

1. User
- id: String (Primary Key)
- email: String (Unique)
- name: String (Optional)
- googleId: String (Unique, Optional)
- passwordHash: String (Optional)
- avatar: String (Optional)
- role: String (Default: "user")
- createdAt: DateTime
- updatedAt: DateTime

2. Tenant
Represents a Shopify store connection:
- id: String (UUID, Primary Key)
- tenantId: String (Unique)
- shopDomain: String (Unique, Shopify domain)
- accessToken: String (Shopify API access token)
- scopes: String (OAuth scopes)
- shopName: String (Optional)
- email: String (Optional)
- currency: String (Default: "USD")
- timezone: String (Optional)
- status: String (Default: "active")
- productsCursor: DateTime (For delta sync)
- customersCursor: DateTime (For delta sync)
- ordersCursor: DateTime (For delta sync)
- createdAt: DateTime
- updatedAt: DateTime

3. Product
- id: String (UUID, Primary Key)
- tenantId: String (Foreign Key to Tenant)
- shopId: BigInt (Shopify product ID)
- title: String
- status: String (Optional)
- priceMin: Decimal (Optional)
- priceMax: Decimal (Optional)
- createdAt: DateTime
- updatedAt: DateTime

4. Customer
- id: String (UUID, Primary Key)
- tenantId: String (Foreign Key to Tenant)
- shopId: BigInt (Shopify customer ID)
- email: String (Optional)
- firstName: String (Optional)
- lastName: String (Optional)
- totalSpent: Decimal (Optional)
- ordersCount: Int (Default: 0)
- createdAt: DateTime
- updatedAt: DateTime

5. Order
- id: String (UUID, Primary Key)
- tenantId: String (Foreign Key to Tenant)
- shopId: BigInt (Shopify order ID)
- customerShopId: BigInt (Optional)
- name: String (Optional)
- currency: String (Optional)
- financialStatus: String (Optional)
- fulfillmentStatus: String (Optional)
- totalPrice: Decimal
- subtotalPrice: Decimal (Optional)
- totalTax: Decimal (Optional)
- totalDiscount: Decimal (Optional)
- createdAt: DateTime
- processedAt: DateTime (Optional)
- updatedAt: DateTime

6. LineItem
- id: String (UUID, Primary Key)
- orderId: String (Foreign Key to Order)
- shopId: BigInt (Optional)
- productShopId: BigInt (Optional)
- title: String (Optional)
- quantity: Int (Default: 0)
- price: Decimal (Optional)
- totalDiscount: Decimal (Optional)
- sku: String (Optional)

7. WebhookEvent
- id: String (UUID, Primary Key)
- tenantId: String (Foreign Key to Tenant)
- topic: String
- shopDomain: String
- payload: Json
- receivedAt: DateTime

================================================================================

6. API ENDPOINTS

AUTHENTICATION ENDPOINTS
- GET /auth/google - Initiate Google OAuth flow
- GET /auth/google/callback - Google OAuth callback
- GET /auth/user - Get current user information
- GET /auth/current - Get current authenticated user
- POST /auth/logout - Logout current user

SHOPIFY INTEGRATION ENDPOINTS
- GET /auth/shopify - Start Shopify app installation
- GET /auth/shopify/callback - Shopify OAuth callback

DATA INGESTION ENDPOINTS
- POST /ingest/full - Full data ingestion for a tenant
- POST /ingest/products - Ingest products for a tenant
- POST /ingest/customers - Ingest customers for a tenant
- POST /ingest/orders - Ingest orders for a tenant
- GET /ingest/delta - Delta sync for updated data
- POST /ingest/direct/all - Direct ingestion for development
- POST /ingest/direct/products - Direct product ingestion
- POST /ingest/direct/customers - Direct customer ingestion
- POST /ingest/direct/orders - Direct order ingestion

BUSINESS INSIGHTS ENDPOINTS
- GET /insights/summary - Summary statistics
- GET /insights/orders-by-date - Orders grouped by date
- GET /insights/top-customers - Top customers by spending
- GET /insights/top-products - Top products by revenue
- GET /insights/recent-orders - Recent orders with pagination

UTILITY ENDPOINTS
- GET / - API root with health information
- GET /health - Health check endpoint
- GET /api/data-summary - Data summary for all tenants

================================================================================

7. AUTHENTICATION

GOOGLE OAUTH FLOW
1. User visits /auth/google
2. Redirected to Google OAuth consent screen
3. After consent, Google redirects to /auth/google/callback
4. Backend exchanges code for access token
5. User information is retrieved and stored/updated in database
6. Session is created and user is redirected to frontend

SESSION MANAGEMENT
- Uses express-session for session management
- Sessions are stored in memory (can be configured for production)
- Session cookies are secured with HttpOnly, Secure, and SameSite flags
- Session secret is configured through environment variables

JWT TOKENS (DISABLED IN CURRENT IMPLEMENTATION)
- JWT tokens were implemented but are currently disabled
- Tokens would be used for stateless authentication
- Refresh tokens for long-lived sessions

AUTHENTICATION MIDDLEWARE
- sessionAuth.js: Verifies session-based authentication
- auth.js: Verifies JWT tokens (currently disabled)
- adminOnly.js: Restricts access to admin users

================================================================================

8. DATA INGESTION

FULL SYNC
- Retrieves all products, customers, and orders from Shopify
- Updates local database with latest information
- Clears relevant cache entries after sync

DELTA SYNC
- Uses updated_at_min parameter to fetch only updated records
- Maintains cursors for each data type (products, customers, orders)
- Automatically runs every 15 minutes via cron job
- Updates cursors after successful sync

DIRECT INGESTION (DEVELOPMENT ONLY)
- Allows direct data ingestion without tenant context
- Only available in development environment
- Uses environment variables for shop domain and access token

RATE LIMITING
- Implements exponential backoff for Shopify API calls
- Automatically retries failed requests with 429/5xx errors
- Waits between requests to avoid hitting rate limits

PAGINATION
- Shopify API responses are paginated
- Backend processes all pages automatically
- Default page size is 250 records

================================================================================

9. MIDDLEWARE

TENANT RESOLUTION (tenant.js)
- Resolves tenant context from headers or query parameters
- Automatically uses first available tenant if none specified
- Verifies tenant is active before proceeding

AUTHENTICATION (sessionAuth.js, auth.js)
- Verifies user authentication through session or JWT
- Currently bypassed in the implementation

ADMIN ACCESS (adminOnly.js)
- Restricts access to users with admin role
- Currently bypassed in the implementation

CACHING (cache.js)
- Caches API responses using Redis
- Tenant-specific cache keys
- Automatic cache invalidation on data updates

RATE LIMITING (rateLimiter.js)
- Limits number of requests per IP address
- Configurable window and request limits
- Prevents abuse and DoS attacks

ERROR HANDLING (errorHandler.js)
- Centralized error handling for all routes
- Formats error responses consistently
- Logs errors for debugging

SECURITY (shopifyHmac.js)
- Verifies HMAC signatures on Shopify webhooks
- Prevents unauthorized webhook requests
- Uses Shopify API secret for verification

================================================================================

10. INTERVIEW QUESTIONS

ARCHITECTURE & DESIGN
1. Q: Explain the multi-tenant architecture of this application.
   A: The application uses a shared database with tenant isolation. Each Shopify store is a separate tenant identified by a unique ID. All database queries include the tenant ID to ensure data isolation. Redis cache keys are also tenant-specific.

2. Q: Why did you choose Prisma ORM over other options like Sequelize or TypeORM?
   A: Prisma offers type safety, auto-generated client, and excellent developer experience. It reduces database-related bugs and provides better performance with its query engine.

3. Q: How does the delta sync mechanism work?
   A: Delta sync uses the updated_at_min parameter in Shopify API calls to fetch only updated records. Timestamps are stored per tenant and data type, and updated after each successful sync.

SECURITY
4. Q: How do you ensure webhook security from Shopify?
   A: All webhooks are verified using HMAC signatures. The shopifyHmac.js middleware validates the signature using the Shopify API secret before processing any webhook data.

5. Q: What security measures are implemented for session management?
   A: Sessions use HttpOnly, Secure, and SameSite cookies. Session secrets are stored in environment variables. CORS is properly configured to prevent unauthorized cross-origin requests.

6. Q: How do you prevent rate limiting issues with Shopify API?
   A: We implement exponential backoff for failed requests with 429/5xx status codes. We also add delays between requests and automatically retry failed requests up to 5 times.

PERFORMANCE
7. Q: How does Redis caching improve performance?
   A: Redis caches frequently accessed data like insights and summaries. Cache keys are tenant-specific, and caches are invalidated when underlying data changes.

8. Q: How do you handle large data sets during ingestion?
   A: Shopify API responses are paginated (250 records per page). We process each page sequentially and use rate limiting to avoid overwhelming the API.

ERROR HANDLING
9. Q: How are errors handled in the application?
   A: We use centralized error handling middleware that formats error responses consistently. Errors are logged for debugging, and appropriate HTTP status codes are returned.

10. Q: What happens if a Shopify API call fails during ingestion?
    A: Failed requests with retryable errors (429, 5xx) are automatically retried with exponential backoff. Non-retryable errors are logged and the ingestion continues with other data.

SCALABILITY
11. Q: How would you scale this application for thousands of Shopify stores?
    A: We would implement database sharding by tenant, use Redis clusters, and deploy the application across multiple regions. Background jobs could be moved to a dedicated queue system.

12. Q: How does the cron scheduler work for delta sync?
    A: A cron job runs every 15 minutes (configurable) and processes all active tenants. Each tenant's data is synced in sequence with proper error handling.

DEPLOYMENT & OPERATIONS
13. Q: What environment variables are critical for this application?
    A: Critical variables include DATABASE_URL, SHOPIFY_API_KEY, SHOPIFY_API_SECRET, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and SESSION_SECRET.

14. Q: How do you handle database migrations?
    A: We use Prisma migrations. New migrations are created with prisma migrate dev and deployed with prisma migrate deploy.

15. Q: How would you monitor the health of this application?
    A: The /health endpoint provides database connectivity status. We would also implement application performance monitoring and log aggregation.

================================================================================

11. DIRECTORY STRUCTURE

backend/
├── config/
│   ├── passport.js          # Google OAuth configuration
│   ├── redis.js             # Redis client setup
│   └── shopify.js           # Shopify API client and utilities
├── controllers/
│   ├── auth.controller.js   # Authentication handlers
│   ├── ingest.controller.js # Data ingestion handlers
│   ├── insights.controller.js # Business insights handlers
│   ├── shopify.controller.js # Shopify integration handlers
│   └── webhook.controller.js # Webhook processing handlers
├── middleware/
│   ├── adminOnly.js         # Admin access restriction
│   ├── auth.js              # JWT authentication
│   ├── cache.js             # Response caching
│   ├── errorHandler.js      # Centralized error handling
│   ├── rateLimiter.js       # Rate limiting
│   ├── sessionAuth.js       # Session authentication
│   ├── shopifyHmac.js       # Shopify webhook verification
│   └── tenant.js            # Tenant resolution
├── models/
│   └── db.js               # Prisma client initialization
├── prisma/
│   ├── schema.prisma        # Database schema definition
│   └── migrations/          # Database migration files
├── repositories/
│   ├── customer.repo.js     # Customer data operations
│   ├── order.repo.js        # Order data operations
│   ├── product.repo.js      # Product data operations
│   ├── tenant.repo.js       # Tenant data operations
│   └── webhookEvent.repo.js # Webhook event logging
├── routes/
│   ├── auth.routes.js       # Authentication routes
│   ├── ingest.routes.js     # Data ingestion routes
│   ├── insights.routes.js   # Business insights routes
│   └── shopify.routes.js    # Shopify integration routes
├── services/
│   ├── ingest.service.js    # Data ingestion logic
│   ├── shopify.service.js   # Shopify integration logic
│   └── webhook.service.js   # Webhook processing logic
├── utils/
│   ├── crypto.js            # Cryptographic utilities
│   ├── env.js               # Environment variable validation
│   └── shopify-ingest.js    # CLI utility for data ingestion
├── index.js                 # Application entry point
├── package.json             # Dependencies and scripts
└── .env.example             # Environment variable examples

KEY FILES EXPLAINED

1. index.js: Main application entry point that initializes Express, middleware, routes, and starts the server
2. package.json: Defines dependencies, scripts, and project metadata
3. prisma/schema.prisma: Database schema definition using Prisma schema language
4. config/passport.js: Google OAuth strategy configuration
5. config/shopify.js: Shopify API client with HMAC verification utilities
6. controllers/*.js: HTTP request handlers for different functionalities
7. middleware/*.js: Express middleware for authentication, caching, error handling, etc.
8. repositories/*.js: Data access layer implementing repository pattern
9. routes/*.js: API route definitions mapping URLs to controllers
10. services/*.js: Business logic implementation separated from controllers
11. utils/*.js: Utility functions for environment, crypto, and CLI operations

This documentation provides a comprehensive overview of the Shopify Xeno Backend, covering its architecture, components, data flow, and implementation details. It should serve as a complete reference for understanding and working with the system.